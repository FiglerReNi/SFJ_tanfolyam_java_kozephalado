Elmélet:
	- A régebbi számítógépekben a CPU egy adott egységből állt. Ez egyszerre egy feladatot képes végezni, ha párhuzamosan több feladat fut, akkor épes közöttük nagyon gyorsan váltogatni, így mindegyik halad valamennyire.
	- Megjelentek később a multi-core gépek, amelyben valahány magos processzor egység van. Itt a magok ténylegesen külön feladatokat végeznek el.
	- Threadek: Virtuálisan több szálat hozhatunk létre, amelyek egymás mellett futnak. Ezek ún. logikai processzorok. Egy programon belül képesek ezek futni. Rendelkeznek egy közös memória területtel, ahonnan kivehetnek számukra szükséges erőforrást. Az operáció rendszer és a JVM dönti el, hogy fizikálisan melyik processzor egységen fognak ezek futni.
	- Multitasking: Több program fut egyidőben, és a fizikai core-ok lehetővé teszik, hogy mindegyik más programot futtasson.
	- Multithreading: Egy programon belül fut több szál.
	
Használat:
	- Új szál létrehozása erőforrás igényes, ezért kis alkalmazásokhoz nem javasolt.
	- Nagyobb számítási munkáknál van értelme.
	- A szálak újra felhasználhatóak, ha úgy használjuk a kódban
	- A szinkronizáció használata lassítja az alkalmazást (ez az amikor a szálaknak be kell várniuk egymást, ha ugyanahhoz a változóhoz kell például hozzáférniük, egyszerre csak egyik dolgozhat rajta)
	
Cél: 
	- Gyorsabban fusson az alkalmazás.
	
Létrehozás:
	- Egy osztály kiterjesztésével extends Thread
	- Interface implementálása implements Runnable
	
Tudnivalók:
	- Amikor a program elindul a main függvénnyel kapunk egy alap szálat.
	- Ha elindítok még egy szálat egymás mellett futnak
	- Egy magos processzoron is tud futni több szál, ha a hyperthreading technológiával kompatibilis. Viszont folyamatosan váltogatni fogja a processzor, hogy melyiken dolgozik.
	- Ha több szálunk van mint a processzorok száma, az operációs rendszer és a JVM felelős azért, hogy a lehető legjobb megoldással futtassa őket.
	- Amikor elindítunk egy alkalmazást, meg tudjuk határozni a heap méretét (JVM-ben tárolt memóriarész). Tartományt is meg lehet adni. Viszont minél nagyobb a heap, annál kevesebb szál lesz képes futni. Fordított arányosság.
	
Volatile:
	- Meggátolja egy változó cachelését. Ez szálaknál lehet fontos, ha egyik szálból akarunk hatással lenni egy másikra egy változó értékének állításával. Viszont ha az a változó cachel, ez nem fog működni. A cache oka, hogy a JVM megvizsgálja az osztályt és azt látja, hogy osztályon belül semmi nem állítja az értékét a változónak. És mivel ez egy szál nem feltételezi, hogy máshonnan állítva lesz ez az érték. Ezért cacheli. 

Join:
	- szálak bevárása

Atomic:
	- feladatok összességét logikai egységnek teintjük. Összevonjuk őket egy egységbe. És ha valami megzavarja a folyamatot, akkor az egészet érvénytelenítenünk kell, ha atomic a folyamat. Csak akkor történik meg, ha ténylegesen minden része meg tud történni. Ha valamelyik része nem tud lefutni az atomic kódhalmaznak, akkor az egészet kidobjuk, mintha le se futott volna. (revertálunk - visszaállunk). Tranzakcióknál fontos.
		pl. macskakaja vásárlás --> több részfeladatból áll
		Ha azt mondjuk, hogy ez legyen atomic, akkor, ha valamelyik részfeladat nem hajtható végre (pl. nincs macskakaja), akkor az egész értelmetlen és vissza kell csinálni a kezdőpontba mindent.
	
Synchronized:
	- Akkor van rá szükség, ha két szál ugyanazt a változót módosítaná folyamatosan. A szálak egymással párhuzamosan futnak, így előfordulhat, hogy ugyanazt az erőforrást használják egyidőben, ugyanazt a változó értéket módosítják egyszerre, nem várják be egymást.
	- Az objektumot, vagy az objektumnak egy részét le tudjuk zárni, lockolni pl egy metódusát.
	- A metódus atomic-á válik, egyben fog lefutni. Ha meghívja az egyik szál teljesen le kell futnia, és csak ha végzett akkor dolgozhat rajta a másik szál. Amíg tart az egyik folyamat lezárjuk a másik elől a metódust.
	- Lassítja a folyamatot, hiszen előfordulhat, hogy az egyik szál vár a másikra.
	- A változó automatikusan Volatile lesz.
	- Amikor synchronized-ot használunk maga az objektum lockolódik, tehát ha van benne két metódus ami synchronized, akkor ha az egyiket használja egy szál, a másikat hiába nem, akkor sem használhatja egy másik szál. Megoldás: ha a metóduson belül a kódot tesszük synchronized-é. Maga a metódus nem lesz synchronized, de a benne található kód igen.
	
ExecutorService: 
	-Ha nem két feladatot szeretnék külön szálakon, és nem én akarom létrehozni a szálakat, hanem csak egy feladatot szeretnék gyorsan elvégezni, rendelhetek hozzá több szálat. A szálaknak az executor adagolja a feladatot.
